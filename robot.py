# -*- coding: utf-8 -*-
"""Robot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-BO_7Qu8ODNAbQRK4_VT-I3JXPZLV7CL

#Configurando el ambiente
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from bs4 import BeautifulSoup
from urllib.request import urlopen

#response = urlopen(url)
#html = response.read()
#soup = BeautifulSoup(html, "html.parser")
#soup.find("span", class_="sc-65e7f566-0 clvjgF base-text").get_text()

"""## Comprobando el ambiente"""

!python -V
print('------')
!pip show Pandas | grep 'Name\|Version'
print('------')
!pip show Numpy | grep 'Name\|Version'
print('------')
!pip show Matplotlib | grep 'Name\|Version'

#Se definen variables globales
df_bitcoin = None
precio_actual = None
tendencia = None
media_bitcoin = None
algoritmo_decision = None

"""#Obtención de datos

Crea una funcion importar_base_bitcoin(), dentro de ella, define nuevamente las variables globales(ver Paso1) y escribe tu código:

Utiliza la biblioteca yfinance de Python para extraer el histórico de precios del Bitcoin en dólares BTC-USD, deberás extraer el histórico de los últimos 7 días en intervalos de 5 minutos, este histórico deberás guardarlo en el dataframe df_bitcoin.
"""

#pip install yfinance

import yfinance as yf

def importar_base_bitcoin():
  #Se definen nuevemente las variables globales
  global df_bitcoin, precio_actual, tendencia, media_bitcoin,  algoritmo_decision

  #Obtener la información del Bitcoin
  bitcoin = yf.Ticker("BTC-USD")

  #Extraer el histórico de precios
  df_bitcoin = bitcoin.history(period="5d", interval="5m")

  print(df_bitcoin)
  return df_bitcoin

importar_base_bitcoin()

"""Crea una funcion extraer_tendencias(), dentro de ella, define nuevamente las variables globales(ver Paso1) y escribe tu código:

Utilizando la biblioteca BeautifulSoup deberás realizar Web Scraping de la página https://coinmarketcap.com/ para extraer el precio actual del Bitcoin BTC en dólares USD y la variación de su precio en la última hora 1h % . El precio deberás convertirlo a float y guardarlo en la variable llamada precio_actual.  Ahora, en la variable tendencia guarda el valor de 'baja'si la variación del precio es negativa, sino, guarda el valor de 'alta'.
"""

import bs4
from urllib.request import Request, urlopen

def extraer_tendencias():
  global df_bitcoin, precio_actual, tendencia, media_bitcoin,  algoritmo_decision

  #Obtener HTML
  url = "https://coinmarketcap.com/currencies"
  headers = {'User_Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36'}

  req = Request(url, headers=headers)
  response = urlopen(req)
  html = response.read()
  soup = BeautifulSoup(html, 'html.parser')

  precio = soup.find("div", {"class":"sc-b3fc6b7-0 dzgUIj"})
  precio_actual = precio.getText()
  precio_actual
  #Se convierte el precio actual a float
  precio_actual = precio_actual.replace('$', '',).replace(',','')
  precio_actual = float(precio_actual)

  #Se obtiene el porcentaje de una hora
  porcentaje = soup.find("span", {"class" : "sc-a59753b0-0 cmnujh"})
  porcentaje = porcentaje.getText()
  #Limpiando y convirtiendo string
  porcentaje = porcentaje.replace('%','')
  porcentaje = float(porcentaje)

  #Asignando la tendencia
  if porcentaje < 0:
    tendencia = "baja"
  else:
    tendencia = "alta"

  return precio_actual, tendencia

extraer_tendencias()

"""Limpieza de datos

Crea una funcion limpieza_datos(), dentro de ella, define nuevamente las variables globales(ver Paso1) y escribe tu código:

Antes de limpiar la base, crea una copia de la base df_bitcoin para que realices la limpieza en esta nueva base(df_bitcoin_limpio), sin modificar la base original, además es importante entender su contenido:

Datetime: Es el índice del dataframe, y contiene la fecha y hora del intervalo seleccionado, no puede estar duplicado.

Open: Contiene el precio del Bitcoin al inicio del intervalo.

High: Contiene el precio más alto del Bitcoin durante el intervalo.

Low: Contiene el precio más bajo del Bitcoin durante el intervalo.

Close: Contiene el precio del Bitcoin al final del intervalo.

Volume: Contiene el total de transacciones hechas durante el intervalo.

Para la limpieza utilizaremos los atributos Datetime, Close y Volume.

Analiza la base df_bitcoin_limpio, identifica duplicados en el índice y trátalos para quedarte con sólo índices únicos.

Luego busca por valores nulos en la columna Close y trátalos.

Verifica que todos los registros de la base tengan un Volume de transacción mayor a 0, caso contrário, elimínalos.

Deberás identificar y eliminar los outliers en el precio del Bitcoin, columna Close, utiliza un gráfico de boxplot para identificarlos.

Filtra o selecciona únicamente los registros cuyo precio(Close) se encuentren entre el 1er cuartil(Q1) y el 3er cuartil(Q3) del boxplot.

Finalmente, calcula el precio promedio(Close) de esta selección y guárdala en la variable media_bitcoin.
"""

#copia de la base de datos
copia_bd = df_bitcoin.copy()

"""Visualización
Crea una funcion visualizacion(), dentro de ella, define nuevamente las variables globales(ver Paso1) y escribe tu código:

Adiciona una nueva columna (Promedio) al dataframe original df_bitcoin y almacena el valor de nuestra variable media_bitcoin.
Configura el tamaño del gráfico en una proporción de 16x5.
Adiciona un título al gráfico.
Usando el método plot()dibuja una línea en el gráfico, con los datos del índice y la columna Close de la base df_bitcoin.
Usando el método plot()dibuja una línea en el gráfico, con los datos del índice y la columna Promedio de la base df_bitcoin.
Usando el método annotate()muestra un mensaje dentro del gráfico con la decisión calculada del algoritmo.
Finalmente, usando el método show()muestra en pantalla el gráfico que acabamos de configurar.
"""

def limpieza_datos():
  global  df_bitcoin, precio_actual, tendencia, media_bitcoin,  algoritmo_decision

  #Se eliminan duplicados
  df_bitcoin = df_bitcoin[["Close", "Volume"]]
  df_bitcoin = df_bitcoin.reset_index()
  df_bitcoin = df_bitcoin.drop_duplicates(subset = 'Datetime')
  df_bitcoin = df_bitcoin.set_index('Datetime')

  #Se manejan valores nulos
  media = df_bitcoin["Close"].mean()
  df_bitcoin["Close"] = df_bitcoin['Close'].fillna(media)

  df_bitcoin = df_bitcoin[df_bitcoin['Volume'] > 0]

  #Se calculan cuartiles
  Q1 = df_bitcoin['Close'].quantile(0.25)
  Q3 = df_bitcoin['Close'].quantile(0.75)
  IQR = Q3 - Q1

  lower_bound = Q1 - 1.5 * IQR
  upper_bound = Q3 + 1.5 * IQR
  lower_bound, upper_bound

  df_filtered = df_bitcoin[(df_bitcoin['Close'] >= lower_bound) & (df_bitcoin['Close'] <= upper_bound)]

  #Se calcula la media
  media_bitcoin = df_filtered['Close'].mean()

  return df_filtered, media_bitcoin, df_bitcoin

limpieza_datos()

sns.boxplot(data= df_bitcoin, y= "Close")
plt.show()

"""Crea una funcion tomar_decisiones(), dentro de ella, define nuevamente las variables globales(ver Paso1) y escribe tu código:

Rellena la variable algoritmo_decision con el valor resultante del siguiente criterio de decisión:
Si el precio actual es mayor/igual que el precio promedio y la tendencia es de baja, entonces guarda el valor ‘Vender’.
Si el precio actual es menor que el precio promedio y la tendencia es de alta, entonces guarda el valor ‘Comprar’.
Si ninguna de las 2 condiciones anteriores se cumple, entonces guarda el valor 'Esperar'.
"""

def tomar_decisiones():
  global  df_bitcoin, precio_actual, tendencia, media_bitcoin,  algoritmo_decision

  if precio_actual >= media_bitcoin and tendencia == 'baja':
    algoritmo_decision = 'Vender'
  elif precio_actual < media_bitcoin and tendencia == 'alta':
    algoritmo_decision = 'Comprar'
  else:
    algoritmo_decision = 'Esperar'
  print(f"El algoritmo sugiere: {algoritmo_decision}")
tomar_decisiones()

def visualizacion():
  global  df_bitcoin, precio_actual, tendencia, media_bitcoin,  algoritmo_decision

  df_bitcoin['Promedio'] = media_bitcoin

  fig, ax = plt.subplots(figsize = (16,5))
  ax.set_title("Valor promedio de Bitcoin")
  sns.lineplot(data = df_bitcoin,
            x = 'Datetime',
            y = 'Close',
            label='Close')

  sns.lineplot(data= df_bitcoin,
              x = 'Datetime',
              y = 'Promedio',
              label = 'Promedio')

  ax.annotate(
        f"Decisión: {algoritmo_decision}",
        xy=(df_bitcoin.index[-1],df_bitcoin['Close'][-1]),
        xytext=(df_bitcoin.index[-1], media_bitcoin + 5000),
        arrowprops=dict(facecolor='black', shrink=0.05),
        fontsize=12,
        color='black'
  )

  plt.show()

visualizacion()

"""Automatización
El trabajo de un Data Scientist sólo termina cuando la solución al problema está automatizada, esto permite soluciones automáticas para nuevos lotes de información.

Importa el método 'clear_output()', este método nos permite borrar los resultados de la pantalla antes de imprimir un nuevo gráfico, y así evitar tener más de un gráfico en la pantalla, impórtalo de la siguiente forma: from IPython.display import clear_output.
Importa también la biblioteca ‘time’ de la siguiente forma: import time, utilizaremos su método time.sleep(300) para interrumpir la ejecución del código cada 300 segundos o 5 minutos.
Finalmente construiremos un loop infinito para ejecutar permanentemente y en intervalos de 5minutos, las funciones que hemos construído en los pasos 2 al 5 de nuestro proyecto, de la siguiente forma:
while(True):
  clear_output()
  importar_base_bitcoin()
  extraer_tendencias()
  limpieza_datos()
  tomar_decisiones()
  visualizacion()
  time.sleep(300)
El resultado de este código será un gráfico mostrando el histórico de precios del Bitcoin y la decisión del algoritmo en tiempo real, basado en datos normalizados y limpios, que se actualizarán cada 5 minutos.

Conclusión
Este desafío sólo fue una demonstración de un proyecto real, donde vemos el poder de los datos para la toma de decisiones y la importancia que tiene el tratamiento de los datos para evitar tomar decisiones equivocadas, durante este Bootcamp aprenderás nuevas herramientas y habilidades que te llevarán a ti y a este proyecto a un nuevo nivel.

¡Ahora, tu misión, si decides aceptarla, es, superar este Robot! ¡Suerte!
"""

from IPython.display import clear_output
import time

while True:
  clear_output()
  importar_base_bitcoin()
  extraer_tendencias()
  limpieza_datos()
  tomar_decisiones()
  visualizacion()
  time.sleep(20)